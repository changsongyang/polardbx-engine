// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paxos.proto

#include "paxos.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace alisql {
constexpr LogEntry::LogEntry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ikey_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , opaque_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , term_(uint64_t{0u})
  , index_(uint64_t{0u})
  , optype_(uint64_t{0u})
  , info_(uint64_t{0u})
  , checksum_(uint64_t{0u}){}
struct LogEntryDefaultTypeInternal {
  constexpr LogEntryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LogEntryDefaultTypeInternal() {}
  union {
    LogEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LogEntryDefaultTypeInternal _LogEntry_default_instance_;
constexpr RDSFields::RDSFields(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : rdsserverid_(0u)
  , source_(0u){}
struct RDSFieldsDefaultTypeInternal {
  constexpr RDSFieldsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RDSFieldsDefaultTypeInternal() {}
  union {
    RDSFields _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RDSFieldsDefaultTypeInternal _RDSFields_default_instance_;
constexpr PolarFields::PolarFields(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : extra_value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , start_lsn_(uint64_t{0u})
  , version_(0u){}
struct PolarFieldsDefaultTypeInternal {
  constexpr PolarFieldsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PolarFieldsDefaultTypeInternal() {}
  union {
    PolarFields _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PolarFieldsDefaultTypeInternal _PolarFields_default_instance_;
constexpr CompressedLogEntries::CompressedLogEntries(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0u)
  , rawsize_(0u)
  , checksum_(0u){}
struct CompressedLogEntriesDefaultTypeInternal {
  constexpr CompressedLogEntriesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CompressedLogEntriesDefaultTypeInternal() {}
  union {
    CompressedLogEntries _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CompressedLogEntriesDefaultTypeInternal _CompressedLogEntries_default_instance_;
constexpr ConfigureChangeValue::ConfigureChangeValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : addrs_()
  , allservers_()
  , alllearners_()
  , cctype_(0)
  , optype_(0)
  , serverid_(uint64_t{0u})
  , forcesync_(0u)
  , electionweight_(0u)
  , learnersource_(uint64_t{0u})
  , applymode_(false){}
struct ConfigureChangeValueDefaultTypeInternal {
  constexpr ConfigureChangeValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConfigureChangeValueDefaultTypeInternal() {}
  union {
    ConfigureChangeValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConfigureChangeValueDefaultTypeInternal _ConfigureChangeValue_default_instance_;
constexpr ClusterInfoEntry::ClusterInfoEntry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : serverid_(uint64_t{0u})
  , matchindex_(uint64_t{0u})
  , nextindex_(uint64_t{0u})
  , hasvoted_(uint64_t{0u})
  , role_(0u)
  , forcesync_(0u)
  , learnersource_(uint64_t{0u})
  , electionweight_(0u)
  , pipelining_(0u)
  , appliedindex_(uint64_t{0u}){}
struct ClusterInfoEntryDefaultTypeInternal {
  constexpr ClusterInfoEntryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ClusterInfoEntryDefaultTypeInternal() {}
  union {
    ClusterInfoEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ClusterInfoEntryDefaultTypeInternal _ClusterInfoEntry_default_instance_;
constexpr PaxosMsg::PaxosMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_()
  , cientries_()
  , addr_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , extra_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , compressedentries_(nullptr)
  , configid_(uint64_t{0u})
  , clusterid_(uint64_t{0u})
  , serverid_(uint64_t{0u})
  , term_(uint64_t{0u})
  , msgid_(uint64_t{0u})
  , leaderid_(uint64_t{0u})
  , prevlogindex_(uint64_t{0u})
  , prevlogterm_(uint64_t{0u})
  , commitindex_(uint64_t{0u})
  , msgtype_(0)
  , nocache_(false)
  , issuccess_(false)
  , votegranted_(false)
  , ignorecheck_(false)
  , candidateid_(uint64_t{0u})
  , lastlogindex_(uint64_t{0u})
  , lastlogterm_(uint64_t{0u})
  , force_(uint64_t{0u})
  , lctype_(uint64_t{0u})
  , minmatchindex_(uint64_t{0u})
  , appliedindex_(uint64_t{0u})
  , newclusterid_(uint64_t{0u})
  , role_(0u)
  , msgerror_(0)
{}
struct PaxosMsgDefaultTypeInternal {
  constexpr PaxosMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PaxosMsgDefaultTypeInternal() {}
  union {
    PaxosMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PaxosMsgDefaultTypeInternal _PaxosMsg_default_instance_;
constexpr TestMsg1::TestMsg1(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(uint64_t{0u})
  , c1_(uint64_t{0u}){}
struct TestMsg1DefaultTypeInternal {
  constexpr TestMsg1DefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TestMsg1DefaultTypeInternal() {}
  union {
    TestMsg1 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TestMsg1DefaultTypeInternal _TestMsg1_default_instance_;
constexpr TestMsg2::TestMsg2(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : c2_()
  , id_(uint64_t{0u})
  , c1_(uint64_t{0u}){}
struct TestMsg2DefaultTypeInternal {
  constexpr TestMsg2DefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TestMsg2DefaultTypeInternal() {}
  union {
    TestMsg2 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TestMsg2DefaultTypeInternal _TestMsg2_default_instance_;
}  // namespace alisql
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_paxos_2eproto[9];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_paxos_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_paxos_2eproto = nullptr;

const uint32_t TableStruct_paxos_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, term_),
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, index_),
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, optype_),
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, ikey_),
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, value_),
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, info_),
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, checksum_),
  PROTOBUF_FIELD_OFFSET(::alisql::LogEntry, opaque_),
  3,
  4,
  5,
  0,
  1,
  6,
  7,
  2,
  PROTOBUF_FIELD_OFFSET(::alisql::RDSFields, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::RDSFields, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::RDSFields, rdsserverid_),
  PROTOBUF_FIELD_OFFSET(::alisql::RDSFields, source_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::alisql::PolarFields, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::PolarFields, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::PolarFields, version_),
  PROTOBUF_FIELD_OFFSET(::alisql::PolarFields, start_lsn_),
  PROTOBUF_FIELD_OFFSET(::alisql::PolarFields, extra_value_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::alisql::CompressedLogEntries, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::CompressedLogEntries, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::CompressedLogEntries, type_),
  PROTOBUF_FIELD_OFFSET(::alisql::CompressedLogEntries, rawsize_),
  PROTOBUF_FIELD_OFFSET(::alisql::CompressedLogEntries, data_),
  PROTOBUF_FIELD_OFFSET(::alisql::CompressedLogEntries, checksum_),
  1,
  2,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, cctype_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, optype_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, addrs_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, allservers_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, alllearners_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, serverid_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, forcesync_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, electionweight_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, learnersource_),
  PROTOBUF_FIELD_OFFSET(::alisql::ConfigureChangeValue, applymode_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, serverid_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, matchindex_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, nextindex_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, role_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, hasvoted_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, forcesync_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, electionweight_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, learnersource_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, appliedindex_),
  PROTOBUF_FIELD_OFFSET(::alisql::ClusterInfoEntry, pipelining_),
  0,
  1,
  2,
  4,
  3,
  5,
  7,
  6,
  9,
  8,
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, configid_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, clusterid_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, serverid_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, msgtype_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, term_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, msgid_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, leaderid_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, prevlogindex_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, prevlogterm_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, entries_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, commitindex_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, nocache_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, issuccess_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, candidateid_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, lastlogindex_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, lastlogterm_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, force_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, addr_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, votegranted_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, ignorecheck_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, lctype_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, minmatchindex_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, appliedindex_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, newclusterid_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, cientries_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, role_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, compressedentries_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, extra_),
  PROTOBUF_FIELD_OFFSET(::alisql::PaxosMsg, msgerror_),
  3,
  4,
  5,
  12,
  6,
  7,
  8,
  9,
  10,
  ~0u,
  11,
  13,
  14,
  17,
  18,
  19,
  20,
  0,
  15,
  16,
  21,
  22,
  23,
  24,
  ~0u,
  25,
  2,
  1,
  26,
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg1, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg1, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg1, id_),
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg1, c1_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg2, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg2, id_),
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg2, c1_),
  PROTOBUF_FIELD_OFFSET(::alisql::TestMsg2, c2_),
  0,
  1,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 14, -1, sizeof(::alisql::LogEntry)},
  { 22, 30, -1, sizeof(::alisql::RDSFields)},
  { 32, 41, -1, sizeof(::alisql::PolarFields)},
  { 44, 54, -1, sizeof(::alisql::CompressedLogEntries)},
  { 58, 74, -1, sizeof(::alisql::ConfigureChangeValue)},
  { 84, 100, -1, sizeof(::alisql::ClusterInfoEntry)},
  { 110, 145, -1, sizeof(::alisql::PaxosMsg)},
  { 174, 182, -1, sizeof(::alisql::TestMsg1)},
  { 184, 193, -1, sizeof(::alisql::TestMsg2)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_LogEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_RDSFields_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_PolarFields_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_CompressedLogEntries_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_ConfigureChangeValue_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_ClusterInfoEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_PaxosMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_TestMsg1_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::alisql::_TestMsg2_default_instance_),
};

const char descriptor_table_protodef_paxos_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013paxos.proto\022\006alisql\"\204\001\n\010LogEntry\022\014\n\004te"
  "rm\030\001 \002(\004\022\r\n\005index\030\002 \002(\004\022\016\n\006opType\030\003 \002(\004\022"
  "\014\n\004ikey\030\004 \001(\014\022\r\n\005value\030\005 \001(\014\022\014\n\004info\030\006 \001"
  "(\004\022\020\n\010checksum\030\007 \001(\004\022\016\n\006opaque\030\t \001(\014\"0\n\t"
  "RDSFields\022\023\n\013rdsServerId\030\001 \001(\r\022\016\n\006source"
  "\030\002 \001(\r\"F\n\013PolarFields\022\017\n\007version\030\001 \002(\r\022\021"
  "\n\tstart_lsn\030\002 \002(\004\022\023\n\013extra_value\030\003 \001(\014\"U"
  "\n\024CompressedLogEntries\022\014\n\004type\030\001 \002(\r\022\017\n\007"
  "rawSize\030\002 \002(\r\022\014\n\004data\030\003 \002(\014\022\020\n\010checksum\030"
  "\004 \001(\r\"\325\001\n\024ConfigureChangeValue\022\016\n\006ccType"
  "\030\001 \001(\005\022\016\n\006opType\030\002 \001(\005\022\r\n\005addrs\030\003 \003(\014\022\022\n"
  "\nallServers\030\004 \003(\014\022\023\n\013allLearners\030\005 \003(\014\022\020"
  "\n\010serverId\030\006 \001(\004\022\021\n\tforceSync\030\007 \001(\r\022\026\n\016e"
  "lectionWeight\030\010 \001(\r\022\025\n\rlearnerSource\030\t \001"
  "(\004\022\021\n\tapplyMode\030\n \001(\010\"\327\001\n\020ClusterInfoEnt"
  "ry\022\020\n\010serverId\030\001 \002(\004\022\022\n\nmatchIndex\030\002 \001(\004"
  "\022\021\n\tnextIndex\030\003 \001(\004\022\014\n\004role\030\004 \001(\r\022\020\n\010has"
  "Voted\030\005 \001(\004\022\021\n\tforceSync\030\006 \001(\r\022\026\n\016electi"
  "onWeight\030\007 \001(\r\022\025\n\rlearnerSource\030\010 \001(\004\022\024\n"
  "\014appliedIndex\030\t \001(\004\022\022\n\npipelining\030\n \001(\r\""
  "\274\005\n\010PaxosMsg\022\020\n\010configId\030\001 \001(\004\022\021\n\tcluste"
  "rId\030\002 \002(\004\022\020\n\010serverId\030\003 \002(\004\022\017\n\007msgType\030\004"
  " \002(\005\022\014\n\004term\030\005 \002(\004\022\r\n\005msgId\030\006 \002(\004\022\020\n\010lea"
  "derId\030\007 \001(\004\022\024\n\014prevLogIndex\030\010 \001(\004\022\023\n\013pre"
  "vLogTerm\030\t \001(\004\022!\n\007entries\030\n \003(\0132\020.alisql"
  ".LogEntry\022\023\n\013commitIndex\030\013 \001(\004\022\017\n\007nocach"
  "e\030\014 \001(\010\022\021\n\tisSuccess\030\r \001(\010\022\023\n\013candidateI"
  "d\030\016 \001(\004\022\024\n\014lastLogIndex\030\017 \001(\004\022\023\n\013lastLog"
  "Term\030\020 \001(\004\022\r\n\005force\030\021 \001(\004\022\014\n\004addr\030\022 \001(\014\022"
  "\023\n\013voteGranted\030\023 \001(\010\022\023\n\013ignoreCheck\030\024 \001("
  "\010\022\016\n\006lcType\030\025 \001(\004\022\025\n\rminMatchIndex\030\026 \001(\004"
  "\022\024\n\014appliedIndex\030\027 \001(\004\022\024\n\014newClusterId\030\030"
  " \001(\004\022+\n\tciEntries\030\031 \003(\0132\030.alisql.Cluster"
  "InfoEntry\022\014\n\004role\030\032 \001(\r\0227\n\021compressedEnt"
  "ries\030\033 \001(\0132\034.alisql.CompressedLogEntries"
  "\022\r\n\005extra\030\034 \001(\014\022/\n\010msgError\030\036 \001(\0162\035.alis"
  "ql.PaxosMsg.MsgErrorType\"$\n\014MsgErrorType"
  "\022\010\n\004NONE\020\000\022\n\n\006APPEND\020\001\"\"\n\010TestMsg1\022\n\n\002id"
  "\030\001 \002(\004\022\n\n\002c1\030\002 \001(\004\".\n\010TestMsg2\022\n\n\002id\030\001 \002"
  "(\004\022\n\n\002c1\030\002 \001(\004\022\n\n\002c2\030\003 \003(\004"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_paxos_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_paxos_2eproto = {
  false, false, 1586, descriptor_table_protodef_paxos_2eproto, "paxos.proto", 
  &descriptor_table_paxos_2eproto_once, nullptr, 0, 9,
  schemas, file_default_instances, TableStruct_paxos_2eproto::offsets,
  file_level_metadata_paxos_2eproto, file_level_enum_descriptors_paxos_2eproto, file_level_service_descriptors_paxos_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_paxos_2eproto_getter() {
  return &descriptor_table_paxos_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_paxos_2eproto(&descriptor_table_paxos_2eproto);
namespace alisql {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaxosMsg_MsgErrorType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_paxos_2eproto);
  return file_level_enum_descriptors_paxos_2eproto[0];
}
bool PaxosMsg_MsgErrorType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PaxosMsg_MsgErrorType PaxosMsg::NONE;
constexpr PaxosMsg_MsgErrorType PaxosMsg::APPEND;
constexpr PaxosMsg_MsgErrorType PaxosMsg::MsgErrorType_MIN;
constexpr PaxosMsg_MsgErrorType PaxosMsg::MsgErrorType_MAX;
constexpr int PaxosMsg::MsgErrorType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class LogEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<LogEntry>()._has_bits_);
  static void set_has_term(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_optype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ikey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_opaque(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000038) ^ 0x00000038) != 0;
  }
};

LogEntry::LogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.LogEntry)
}
LogEntry::LogEntry(const LogEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ikey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ikey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ikey()) {
    ikey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ikey(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  opaque_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    opaque_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_opaque()) {
    opaque_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_opaque(), 
      GetArenaForAllocation());
  }
  ::memcpy(&term_, &from.term_,
    static_cast<size_t>(reinterpret_cast<char*>(&checksum_) -
    reinterpret_cast<char*>(&term_)) + sizeof(checksum_));
  // @@protoc_insertion_point(copy_constructor:alisql.LogEntry)
}

inline void LogEntry::SharedCtor() {
ikey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ikey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
opaque_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  opaque_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&term_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&checksum_) -
    reinterpret_cast<char*>(&term_)) + sizeof(checksum_));
}

LogEntry::~LogEntry() {
  // @@protoc_insertion_point(destructor:alisql.LogEntry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LogEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ikey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  opaque_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LogEntry::ArenaDtor(void* object) {
  LogEntry* _this = reinterpret_cast< LogEntry* >(object);
  (void)_this;
}
void LogEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.LogEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ikey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      opaque_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&term_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&checksum_) -
        reinterpret_cast<char*>(&term_)) + sizeof(checksum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 term = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_term(&has_bits);
          term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 opType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_optype(&has_bits);
          optype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ikey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ikey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_info(&has_bits);
          info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 checksum = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_checksum(&has_bits);
          checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes opaque = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_opaque();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.LogEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 term = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_term(), target);
  }

  // required uint64 index = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_index(), target);
  }

  // required uint64 opType = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_optype(), target);
  }

  // optional bytes ikey = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ikey(), target);
  }

  // optional bytes value = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_value(), target);
  }

  // optional uint64 info = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_info(), target);
  }

  // optional uint64 checksum = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_checksum(), target);
  }

  // optional bytes opaque = 9;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_opaque(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.LogEntry)
  return target;
}

size_t LogEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:alisql.LogEntry)
  size_t total_size = 0;

  if (_internal_has_term()) {
    // required uint64 term = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_term());
  }

  if (_internal_has_index()) {
    // required uint64 index = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
  }

  if (_internal_has_optype()) {
    // required uint64 opType = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_optype());
  }

  return total_size;
}
size_t LogEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.LogEntry)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000038) ^ 0x00000038) == 0) {  // All required fields are present.
    // required uint64 term = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_term());

    // required uint64 index = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_index());

    // required uint64 opType = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_optype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes ikey = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ikey());
    }

    // optional bytes value = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

    // optional bytes opaque = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_opaque());
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional uint64 info = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_info());
    }

    // optional uint64 checksum = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_checksum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LogEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogEntry::GetClassData() const { return &_class_data_; }

void LogEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LogEntry *>(to)->MergeFrom(
      static_cast<const LogEntry &>(from));
}


void LogEntry::MergeFrom(const LogEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.LogEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ikey(from._internal_ikey());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_opaque(from._internal_opaque());
    }
    if (cached_has_bits & 0x00000008u) {
      term_ = from.term_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000020u) {
      optype_ = from.optype_;
    }
    if (cached_has_bits & 0x00000040u) {
      info_ = from.info_;
    }
    if (cached_has_bits & 0x00000080u) {
      checksum_ = from.checksum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogEntry::CopyFrom(const LogEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.LogEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LogEntry::InternalSwap(LogEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ikey_, lhs_arena,
      &other->ikey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &opaque_, lhs_arena,
      &other->opaque_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogEntry, checksum_)
      + sizeof(LogEntry::checksum_)
      - PROTOBUF_FIELD_OFFSET(LogEntry, term_)>(
          reinterpret_cast<char*>(&term_),
          reinterpret_cast<char*>(&other->term_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogEntry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[0]);
}

// ===================================================================

class RDSFields::_Internal {
 public:
  using HasBits = decltype(std::declval<RDSFields>()._has_bits_);
  static void set_has_rdsserverid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RDSFields::RDSFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.RDSFields)
}
RDSFields::RDSFields(const RDSFields& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&rdsserverid_, &from.rdsserverid_,
    static_cast<size_t>(reinterpret_cast<char*>(&source_) -
    reinterpret_cast<char*>(&rdsserverid_)) + sizeof(source_));
  // @@protoc_insertion_point(copy_constructor:alisql.RDSFields)
}

inline void RDSFields::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rdsserverid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&source_) -
    reinterpret_cast<char*>(&rdsserverid_)) + sizeof(source_));
}

RDSFields::~RDSFields() {
  // @@protoc_insertion_point(destructor:alisql.RDSFields)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RDSFields::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RDSFields::ArenaDtor(void* object) {
  RDSFields* _this = reinterpret_cast< RDSFields* >(object);
  (void)_this;
}
void RDSFields::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RDSFields::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RDSFields::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.RDSFields)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&rdsserverid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&source_) -
        reinterpret_cast<char*>(&rdsserverid_)) + sizeof(source_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RDSFields::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rdsServerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rdsserverid(&has_bits);
          rdsserverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_source(&has_bits);
          source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RDSFields::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.RDSFields)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 rdsServerId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rdsserverid(), target);
  }

  // optional uint32 source = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_source(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.RDSFields)
  return target;
}

size_t RDSFields::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.RDSFields)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 rdsServerId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rdsserverid());
    }

    // optional uint32 source = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_source());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RDSFields::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RDSFields::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RDSFields::GetClassData() const { return &_class_data_; }

void RDSFields::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RDSFields *>(to)->MergeFrom(
      static_cast<const RDSFields &>(from));
}


void RDSFields::MergeFrom(const RDSFields& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.RDSFields)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      rdsserverid_ = from.rdsserverid_;
    }
    if (cached_has_bits & 0x00000002u) {
      source_ = from.source_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RDSFields::CopyFrom(const RDSFields& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.RDSFields)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RDSFields::IsInitialized() const {
  return true;
}

void RDSFields::InternalSwap(RDSFields* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RDSFields, source_)
      + sizeof(RDSFields::source_)
      - PROTOBUF_FIELD_OFFSET(RDSFields, rdsserverid_)>(
          reinterpret_cast<char*>(&rdsserverid_),
          reinterpret_cast<char*>(&other->rdsserverid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RDSFields::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[1]);
}

// ===================================================================

class PolarFields::_Internal {
 public:
  using HasBits = decltype(std::declval<PolarFields>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_lsn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_extra_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

PolarFields::PolarFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.PolarFields)
}
PolarFields::PolarFields(const PolarFields& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  extra_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extra_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extra_value()) {
    extra_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_extra_value(), 
      GetArenaForAllocation());
  }
  ::memcpy(&start_lsn_, &from.start_lsn_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&start_lsn_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:alisql.PolarFields)
}

inline void PolarFields::SharedCtor() {
extra_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extra_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_lsn_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&start_lsn_)) + sizeof(version_));
}

PolarFields::~PolarFields() {
  // @@protoc_insertion_point(destructor:alisql.PolarFields)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PolarFields::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  extra_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PolarFields::ArenaDtor(void* object) {
  PolarFields* _this = reinterpret_cast< PolarFields* >(object);
  (void)_this;
}
void PolarFields::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PolarFields::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PolarFields::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.PolarFields)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    extra_value_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&start_lsn_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&start_lsn_)) + sizeof(version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PolarFields::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 start_lsn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_start_lsn(&has_bits);
          start_lsn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes extra_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_extra_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolarFields::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.PolarFields)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // required uint64 start_lsn = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_start_lsn(), target);
  }

  // optional bytes extra_value = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_extra_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.PolarFields)
  return target;
}

size_t PolarFields::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:alisql.PolarFields)
  size_t total_size = 0;

  if (_internal_has_start_lsn()) {
    // required uint64 start_lsn = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_start_lsn());
  }

  if (_internal_has_version()) {
    // required uint32 version = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  return total_size;
}
size_t PolarFields::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.PolarFields)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint64 start_lsn = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_start_lsn());

    // required uint32 version = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes extra_value = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_extra_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PolarFields::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PolarFields::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PolarFields::GetClassData() const { return &_class_data_; }

void PolarFields::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PolarFields *>(to)->MergeFrom(
      static_cast<const PolarFields &>(from));
}


void PolarFields::MergeFrom(const PolarFields& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.PolarFields)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_extra_value(from._internal_extra_value());
    }
    if (cached_has_bits & 0x00000002u) {
      start_lsn_ = from.start_lsn_;
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PolarFields::CopyFrom(const PolarFields& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.PolarFields)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolarFields::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PolarFields::InternalSwap(PolarFields* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &extra_value_, lhs_arena,
      &other->extra_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PolarFields, version_)
      + sizeof(PolarFields::version_)
      - PROTOBUF_FIELD_OFFSET(PolarFields, start_lsn_)>(
          reinterpret_cast<char*>(&start_lsn_),
          reinterpret_cast<char*>(&other->start_lsn_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PolarFields::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[2]);
}

// ===================================================================

class CompressedLogEntries::_Internal {
 public:
  using HasBits = decltype(std::declval<CompressedLogEntries>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rawsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CompressedLogEntries::CompressedLogEntries(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.CompressedLogEntries)
}
CompressedLogEntries::CompressedLogEntries(const CompressedLogEntries& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&checksum_) -
    reinterpret_cast<char*>(&type_)) + sizeof(checksum_));
  // @@protoc_insertion_point(copy_constructor:alisql.CompressedLogEntries)
}

inline void CompressedLogEntries::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&checksum_) -
    reinterpret_cast<char*>(&type_)) + sizeof(checksum_));
}

CompressedLogEntries::~CompressedLogEntries() {
  // @@protoc_insertion_point(destructor:alisql.CompressedLogEntries)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CompressedLogEntries::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CompressedLogEntries::ArenaDtor(void* object) {
  CompressedLogEntries* _this = reinterpret_cast< CompressedLogEntries* >(object);
  (void)_this;
}
void CompressedLogEntries::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CompressedLogEntries::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CompressedLogEntries::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.CompressedLogEntries)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&checksum_) -
        reinterpret_cast<char*>(&type_)) + sizeof(checksum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompressedLogEntries::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 rawSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rawsize(&has_bits);
          rawsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 checksum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_checksum(&has_bits);
          checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CompressedLogEntries::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.CompressedLogEntries)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // required uint32 rawSize = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rawsize(), target);
  }

  // required bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // optional uint32 checksum = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_checksum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.CompressedLogEntries)
  return target;
}

size_t CompressedLogEntries::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:alisql.CompressedLogEntries)
  size_t total_size = 0;

  if (_internal_has_data()) {
    // required bytes data = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  if (_internal_has_rawsize()) {
    // required uint32 rawSize = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rawsize());
  }

  return total_size;
}
size_t CompressedLogEntries::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.CompressedLogEntries)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes data = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());

    // required uint32 type = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

    // required uint32 rawSize = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rawsize());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 checksum = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_checksum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompressedLogEntries::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CompressedLogEntries::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompressedLogEntries::GetClassData() const { return &_class_data_; }

void CompressedLogEntries::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CompressedLogEntries *>(to)->MergeFrom(
      static_cast<const CompressedLogEntries &>(from));
}


void CompressedLogEntries::MergeFrom(const CompressedLogEntries& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.CompressedLogEntries)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      rawsize_ = from.rawsize_;
    }
    if (cached_has_bits & 0x00000008u) {
      checksum_ = from.checksum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedLogEntries::CopyFrom(const CompressedLogEntries& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.CompressedLogEntries)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompressedLogEntries::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CompressedLogEntries::InternalSwap(CompressedLogEntries* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CompressedLogEntries, checksum_)
      + sizeof(CompressedLogEntries::checksum_)
      - PROTOBUF_FIELD_OFFSET(CompressedLogEntries, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CompressedLogEntries::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[3]);
}

// ===================================================================

class ConfigureChangeValue::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigureChangeValue>()._has_bits_);
  static void set_has_cctype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_optype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serverid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_forcesync(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_electionweight(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_learnersource(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_applymode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

ConfigureChangeValue::ConfigureChangeValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  addrs_(arena),
  allservers_(arena),
  alllearners_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.ConfigureChangeValue)
}
ConfigureChangeValue::ConfigureChangeValue(const ConfigureChangeValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      addrs_(from.addrs_),
      allservers_(from.allservers_),
      alllearners_(from.alllearners_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&cctype_, &from.cctype_,
    static_cast<size_t>(reinterpret_cast<char*>(&applymode_) -
    reinterpret_cast<char*>(&cctype_)) + sizeof(applymode_));
  // @@protoc_insertion_point(copy_constructor:alisql.ConfigureChangeValue)
}

inline void ConfigureChangeValue::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cctype_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&applymode_) -
    reinterpret_cast<char*>(&cctype_)) + sizeof(applymode_));
}

ConfigureChangeValue::~ConfigureChangeValue() {
  // @@protoc_insertion_point(destructor:alisql.ConfigureChangeValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ConfigureChangeValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConfigureChangeValue::ArenaDtor(void* object) {
  ConfigureChangeValue* _this = reinterpret_cast< ConfigureChangeValue* >(object);
  (void)_this;
}
void ConfigureChangeValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConfigureChangeValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigureChangeValue::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.ConfigureChangeValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  addrs_.Clear();
  allservers_.Clear();
  alllearners_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&cctype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&applymode_) -
        reinterpret_cast<char*>(&cctype_)) + sizeof(applymode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigureChangeValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 ccType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cctype(&has_bits);
          cctype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 opType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_optype(&has_bits);
          optype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes addrs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_addrs();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes allServers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_allservers();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes allLearners = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_alllearners();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 serverId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_serverid(&has_bits);
          serverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 forceSync = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_forcesync(&has_bits);
          forcesync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 electionWeight = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_electionweight(&has_bits);
          electionweight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 learnerSource = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_learnersource(&has_bits);
          learnersource_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool applyMode = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_applymode(&has_bits);
          applymode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigureChangeValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.ConfigureChangeValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 ccType = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_cctype(), target);
  }

  // optional int32 opType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_optype(), target);
  }

  // repeated bytes addrs = 3;
  for (int i = 0, n = this->_internal_addrs_size(); i < n; i++) {
    const auto& s = this->_internal_addrs(i);
    target = stream->WriteBytes(3, s, target);
  }

  // repeated bytes allServers = 4;
  for (int i = 0, n = this->_internal_allservers_size(); i < n; i++) {
    const auto& s = this->_internal_allservers(i);
    target = stream->WriteBytes(4, s, target);
  }

  // repeated bytes allLearners = 5;
  for (int i = 0, n = this->_internal_alllearners_size(); i < n; i++) {
    const auto& s = this->_internal_alllearners(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional uint64 serverId = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_serverid(), target);
  }

  // optional uint32 forceSync = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_forcesync(), target);
  }

  // optional uint32 electionWeight = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_electionweight(), target);
  }

  // optional uint64 learnerSource = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_learnersource(), target);
  }

  // optional bool applyMode = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_applymode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.ConfigureChangeValue)
  return target;
}

size_t ConfigureChangeValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.ConfigureChangeValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes addrs = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(addrs_.size());
  for (int i = 0, n = addrs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      addrs_.Get(i));
  }

  // repeated bytes allServers = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(allservers_.size());
  for (int i = 0, n = allservers_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      allservers_.Get(i));
  }

  // repeated bytes allLearners = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(alllearners_.size());
  for (int i = 0, n = alllearners_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      alllearners_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int32 ccType = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cctype());
    }

    // optional int32 opType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_optype());
    }

    // optional uint64 serverId = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_serverid());
    }

    // optional uint32 forceSync = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_forcesync());
    }

    // optional uint32 electionWeight = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_electionweight());
    }

    // optional uint64 learnerSource = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_learnersource());
    }

    // optional bool applyMode = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigureChangeValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConfigureChangeValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigureChangeValue::GetClassData() const { return &_class_data_; }

void ConfigureChangeValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConfigureChangeValue *>(to)->MergeFrom(
      static_cast<const ConfigureChangeValue &>(from));
}


void ConfigureChangeValue::MergeFrom(const ConfigureChangeValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.ConfigureChangeValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  addrs_.MergeFrom(from.addrs_);
  allservers_.MergeFrom(from.allservers_);
  alllearners_.MergeFrom(from.alllearners_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      cctype_ = from.cctype_;
    }
    if (cached_has_bits & 0x00000002u) {
      optype_ = from.optype_;
    }
    if (cached_has_bits & 0x00000004u) {
      serverid_ = from.serverid_;
    }
    if (cached_has_bits & 0x00000008u) {
      forcesync_ = from.forcesync_;
    }
    if (cached_has_bits & 0x00000010u) {
      electionweight_ = from.electionweight_;
    }
    if (cached_has_bits & 0x00000020u) {
      learnersource_ = from.learnersource_;
    }
    if (cached_has_bits & 0x00000040u) {
      applymode_ = from.applymode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigureChangeValue::CopyFrom(const ConfigureChangeValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.ConfigureChangeValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigureChangeValue::IsInitialized() const {
  return true;
}

void ConfigureChangeValue::InternalSwap(ConfigureChangeValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  addrs_.InternalSwap(&other->addrs_);
  allservers_.InternalSwap(&other->allservers_);
  alllearners_.InternalSwap(&other->alllearners_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigureChangeValue, applymode_)
      + sizeof(ConfigureChangeValue::applymode_)
      - PROTOBUF_FIELD_OFFSET(ConfigureChangeValue, cctype_)>(
          reinterpret_cast<char*>(&cctype_),
          reinterpret_cast<char*>(&other->cctype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigureChangeValue::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[4]);
}

// ===================================================================

class ClusterInfoEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<ClusterInfoEntry>()._has_bits_);
  static void set_has_serverid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_matchindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nextindex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hasvoted(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_forcesync(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_electionweight(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_learnersource(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_appliedindex(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_pipelining(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ClusterInfoEntry::ClusterInfoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.ClusterInfoEntry)
}
ClusterInfoEntry::ClusterInfoEntry(const ClusterInfoEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&serverid_, &from.serverid_,
    static_cast<size_t>(reinterpret_cast<char*>(&appliedindex_) -
    reinterpret_cast<char*>(&serverid_)) + sizeof(appliedindex_));
  // @@protoc_insertion_point(copy_constructor:alisql.ClusterInfoEntry)
}

inline void ClusterInfoEntry::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&serverid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&appliedindex_) -
    reinterpret_cast<char*>(&serverid_)) + sizeof(appliedindex_));
}

ClusterInfoEntry::~ClusterInfoEntry() {
  // @@protoc_insertion_point(destructor:alisql.ClusterInfoEntry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ClusterInfoEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClusterInfoEntry::ArenaDtor(void* object) {
  ClusterInfoEntry* _this = reinterpret_cast< ClusterInfoEntry* >(object);
  (void)_this;
}
void ClusterInfoEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ClusterInfoEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClusterInfoEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.ClusterInfoEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&serverid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&electionweight_) -
        reinterpret_cast<char*>(&serverid_)) + sizeof(electionweight_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&pipelining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appliedindex_) -
        reinterpret_cast<char*>(&pipelining_)) + sizeof(appliedindex_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClusterInfoEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 serverId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_serverid(&has_bits);
          serverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 matchIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_matchindex(&has_bits);
          matchindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 nextIndex = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nextindex(&has_bits);
          nextindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 role = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_role(&has_bits);
          role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 hasVoted = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_hasvoted(&has_bits);
          hasvoted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 forceSync = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_forcesync(&has_bits);
          forcesync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 electionWeight = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_electionweight(&has_bits);
          electionweight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 learnerSource = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_learnersource(&has_bits);
          learnersource_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 appliedIndex = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_appliedindex(&has_bits);
          appliedindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pipelining = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_pipelining(&has_bits);
          pipelining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClusterInfoEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.ClusterInfoEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 serverId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_serverid(), target);
  }

  // optional uint64 matchIndex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_matchindex(), target);
  }

  // optional uint64 nextIndex = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_nextindex(), target);
  }

  // optional uint32 role = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_role(), target);
  }

  // optional uint64 hasVoted = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_hasvoted(), target);
  }

  // optional uint32 forceSync = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_forcesync(), target);
  }

  // optional uint32 electionWeight = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_electionweight(), target);
  }

  // optional uint64 learnerSource = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_learnersource(), target);
  }

  // optional uint64 appliedIndex = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_appliedindex(), target);
  }

  // optional uint32 pipelining = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_pipelining(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.ClusterInfoEntry)
  return target;
}

size_t ClusterInfoEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.ClusterInfoEntry)
  size_t total_size = 0;

  // required uint64 serverId = 1;
  if (_internal_has_serverid()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_serverid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional uint64 matchIndex = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_matchindex());
    }

    // optional uint64 nextIndex = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_nextindex());
    }

    // optional uint64 hasVoted = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_hasvoted());
    }

    // optional uint32 role = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_role());
    }

    // optional uint32 forceSync = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_forcesync());
    }

    // optional uint64 learnerSource = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_learnersource());
    }

    // optional uint32 electionWeight = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_electionweight());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 pipelining = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_pipelining());
    }

    // optional uint64 appliedIndex = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_appliedindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClusterInfoEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ClusterInfoEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClusterInfoEntry::GetClassData() const { return &_class_data_; }

void ClusterInfoEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ClusterInfoEntry *>(to)->MergeFrom(
      static_cast<const ClusterInfoEntry &>(from));
}


void ClusterInfoEntry::MergeFrom(const ClusterInfoEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.ClusterInfoEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      serverid_ = from.serverid_;
    }
    if (cached_has_bits & 0x00000002u) {
      matchindex_ = from.matchindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      nextindex_ = from.nextindex_;
    }
    if (cached_has_bits & 0x00000008u) {
      hasvoted_ = from.hasvoted_;
    }
    if (cached_has_bits & 0x00000010u) {
      role_ = from.role_;
    }
    if (cached_has_bits & 0x00000020u) {
      forcesync_ = from.forcesync_;
    }
    if (cached_has_bits & 0x00000040u) {
      learnersource_ = from.learnersource_;
    }
    if (cached_has_bits & 0x00000080u) {
      electionweight_ = from.electionweight_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      pipelining_ = from.pipelining_;
    }
    if (cached_has_bits & 0x00000200u) {
      appliedindex_ = from.appliedindex_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClusterInfoEntry::CopyFrom(const ClusterInfoEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.ClusterInfoEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClusterInfoEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ClusterInfoEntry::InternalSwap(ClusterInfoEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClusterInfoEntry, appliedindex_)
      + sizeof(ClusterInfoEntry::appliedindex_)
      - PROTOBUF_FIELD_OFFSET(ClusterInfoEntry, serverid_)>(
          reinterpret_cast<char*>(&serverid_),
          reinterpret_cast<char*>(&other->serverid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClusterInfoEntry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[5]);
}

// ===================================================================

class PaxosMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<PaxosMsg>()._has_bits_);
  static void set_has_configid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_clusterid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_serverid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_msgtype(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_term(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_msgid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_leaderid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_prevlogindex(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_prevlogterm(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_commitindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_nocache(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_issuccess(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_candidateid(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_lastlogindex(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_lastlogterm(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_force(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_votegranted(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_ignorecheck(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_lctype(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_minmatchindex(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_appliedindex(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_newclusterid(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::alisql::CompressedLogEntries& compressedentries(const PaxosMsg* msg);
  static void set_has_compressedentries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_extra(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_msgerror(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000010f0) ^ 0x000010f0) != 0;
  }
};

const ::alisql::CompressedLogEntries&
PaxosMsg::_Internal::compressedentries(const PaxosMsg* msg) {
  return *msg->compressedentries_;
}
PaxosMsg::PaxosMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena),
  cientries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.PaxosMsg)
}
PaxosMsg::PaxosMsg(const PaxosMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      entries_(from.entries_),
      cientries_(from.cientries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_addr()) {
    addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_addr(), 
      GetArenaForAllocation());
  }
  extra_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extra()) {
    extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_extra(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_compressedentries()) {
    compressedentries_ = new ::alisql::CompressedLogEntries(*from.compressedentries_);
  } else {
    compressedentries_ = nullptr;
  }
  ::memcpy(&configid_, &from.configid_,
    static_cast<size_t>(reinterpret_cast<char*>(&msgerror_) -
    reinterpret_cast<char*>(&configid_)) + sizeof(msgerror_));
  // @@protoc_insertion_point(copy_constructor:alisql.PaxosMsg)
}

inline void PaxosMsg::SharedCtor() {
addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
extra_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&compressedentries_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&msgerror_) -
    reinterpret_cast<char*>(&compressedentries_)) + sizeof(msgerror_));
}

PaxosMsg::~PaxosMsg() {
  // @@protoc_insertion_point(destructor:alisql.PaxosMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PaxosMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  addr_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  extra_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete compressedentries_;
}

void PaxosMsg::ArenaDtor(void* object) {
  PaxosMsg* _this = reinterpret_cast< PaxosMsg* >(object);
  (void)_this;
}
void PaxosMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PaxosMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PaxosMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.PaxosMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  cientries_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      addr_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      extra_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(compressedentries_ != nullptr);
      compressedentries_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&configid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&msgid_) -
        reinterpret_cast<char*>(&configid_)) + sizeof(msgid_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&leaderid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&votegranted_) -
        reinterpret_cast<char*>(&leaderid_)) + sizeof(votegranted_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&ignorecheck_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appliedindex_) -
        reinterpret_cast<char*>(&ignorecheck_)) + sizeof(appliedindex_));
  }
  if (cached_has_bits & 0x07000000u) {
    ::memset(&newclusterid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&msgerror_) -
        reinterpret_cast<char*>(&newclusterid_)) + sizeof(msgerror_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PaxosMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 configId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_configid(&has_bits);
          configid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 clusterId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_clusterid(&has_bits);
          clusterid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 serverId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_serverid(&has_bits);
          serverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 msgType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_msgtype(&has_bits);
          msgtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 term = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_term(&has_bits);
          term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 msgId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_msgid(&has_bits);
          msgid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 leaderId = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_leaderid(&has_bits);
          leaderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 prevLogIndex = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_prevlogindex(&has_bits);
          prevlogindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 prevLogTerm = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_prevlogterm(&has_bits);
          prevlogterm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .alisql.LogEntry entries = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 commitIndex = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_commitindex(&has_bits);
          commitindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool nocache = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_nocache(&has_bits);
          nocache_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool isSuccess = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_issuccess(&has_bits);
          issuccess_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 candidateId = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_candidateid(&has_bits);
          candidateid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lastLogIndex = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_lastlogindex(&has_bits);
          lastlogindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lastLogTerm = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_lastlogterm(&has_bits);
          lastlogterm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 force = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_force(&has_bits);
          force_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes addr = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_addr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool voteGranted = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_votegranted(&has_bits);
          votegranted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignoreCheck = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_ignorecheck(&has_bits);
          ignorecheck_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lcType = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_lctype(&has_bits);
          lctype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 minMatchIndex = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_minmatchindex(&has_bits);
          minmatchindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 appliedIndex = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_appliedindex(&has_bits);
          appliedindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 newClusterId = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_newclusterid(&has_bits);
          newclusterid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .alisql.ClusterInfoEntry ciEntries = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cientries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<202>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 role = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_role(&has_bits);
          role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .alisql.CompressedLogEntries compressedEntries = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_compressedentries(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes extra = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_extra();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .alisql.PaxosMsg.MsgErrorType msgError = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::alisql::PaxosMsg_MsgErrorType_IsValid(val))) {
            _internal_set_msgerror(static_cast<::alisql::PaxosMsg_MsgErrorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(30, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PaxosMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.PaxosMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 configId = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_configid(), target);
  }

  // required uint64 clusterId = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_clusterid(), target);
  }

  // required uint64 serverId = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_serverid(), target);
  }

  // required int32 msgType = 4;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_msgtype(), target);
  }

  // required uint64 term = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_term(), target);
  }

  // required uint64 msgId = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_msgid(), target);
  }

  // optional uint64 leaderId = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_leaderid(), target);
  }

  // optional uint64 prevLogIndex = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_prevlogindex(), target);
  }

  // optional uint64 prevLogTerm = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_prevlogterm(), target);
  }

  // repeated .alisql.LogEntry entries = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_entries(i), target, stream);
  }

  // optional uint64 commitIndex = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(11, this->_internal_commitindex(), target);
  }

  // optional bool nocache = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_nocache(), target);
  }

  // optional bool isSuccess = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_issuccess(), target);
  }

  // optional uint64 candidateId = 14;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(14, this->_internal_candidateid(), target);
  }

  // optional uint64 lastLogIndex = 15;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(15, this->_internal_lastlogindex(), target);
  }

  // optional uint64 lastLogTerm = 16;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(16, this->_internal_lastlogterm(), target);
  }

  // optional uint64 force = 17;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(17, this->_internal_force(), target);
  }

  // optional bytes addr = 18;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        18, this->_internal_addr(), target);
  }

  // optional bool voteGranted = 19;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_votegranted(), target);
  }

  // optional bool ignoreCheck = 20;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_ignorecheck(), target);
  }

  // optional uint64 lcType = 21;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(21, this->_internal_lctype(), target);
  }

  // optional uint64 minMatchIndex = 22;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(22, this->_internal_minmatchindex(), target);
  }

  // optional uint64 appliedIndex = 23;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(23, this->_internal_appliedindex(), target);
  }

  // optional uint64 newClusterId = 24;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(24, this->_internal_newclusterid(), target);
  }

  // repeated .alisql.ClusterInfoEntry ciEntries = 25;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cientries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, this->_internal_cientries(i), target, stream);
  }

  // optional uint32 role = 26;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(26, this->_internal_role(), target);
  }

  // optional .alisql.CompressedLogEntries compressedEntries = 27;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        27, _Internal::compressedentries(this), target, stream);
  }

  // optional bytes extra = 28;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        28, this->_internal_extra(), target);
  }

  // optional .alisql.PaxosMsg.MsgErrorType msgError = 30;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      30, this->_internal_msgerror(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.PaxosMsg)
  return target;
}

size_t PaxosMsg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:alisql.PaxosMsg)
  size_t total_size = 0;

  if (_internal_has_clusterid()) {
    // required uint64 clusterId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_clusterid());
  }

  if (_internal_has_serverid()) {
    // required uint64 serverId = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_serverid());
  }

  if (_internal_has_term()) {
    // required uint64 term = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_term());
  }

  if (_internal_has_msgid()) {
    // required uint64 msgId = 6;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_msgid());
  }

  if (_internal_has_msgtype()) {
    // required int32 msgType = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_msgtype());
  }

  return total_size;
}
size_t PaxosMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.PaxosMsg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000010f0) ^ 0x000010f0) == 0) {  // All required fields are present.
    // required uint64 clusterId = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_clusterid());

    // required uint64 serverId = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_serverid());

    // required uint64 term = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_term());

    // required uint64 msgId = 6;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_msgid());

    // required int32 msgType = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_msgtype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .alisql.LogEntry entries = 10;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .alisql.ClusterInfoEntry ciEntries = 25;
  total_size += 2UL * this->_internal_cientries_size();
  for (const auto& msg : this->cientries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes addr = 18;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_addr());
    }

    // optional bytes extra = 28;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_extra());
    }

    // optional .alisql.CompressedLogEntries compressedEntries = 27;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *compressedentries_);
    }

    // optional uint64 configId = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_configid());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint64 leaderId = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_leaderid());
    }

    // optional uint64 prevLogIndex = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_prevlogindex());
    }

    // optional uint64 prevLogTerm = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_prevlogterm());
    }

    // optional uint64 commitIndex = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_commitindex());
    }

  }
  if (cached_has_bits & 0x0000e000u) {
    // optional bool nocache = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool isSuccess = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool voteGranted = 19;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool ignoreCheck = 20;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional uint64 candidateId = 14;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_candidateid());
    }

    // optional uint64 lastLogIndex = 15;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_lastlogindex());
    }

    // optional uint64 lastLogTerm = 16;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_lastlogterm());
    }

    // optional uint64 force = 17;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_force());
    }

    // optional uint64 lcType = 21;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_lctype());
    }

    // optional uint64 minMatchIndex = 22;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_minmatchindex());
    }

    // optional uint64 appliedIndex = 23;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_appliedindex());
    }

  }
  if (cached_has_bits & 0x07000000u) {
    // optional uint64 newClusterId = 24;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_newclusterid());
    }

    // optional uint32 role = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_role());
    }

    // optional .alisql.PaxosMsg.MsgErrorType msgError = 30;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_msgerror());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PaxosMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PaxosMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PaxosMsg::GetClassData() const { return &_class_data_; }

void PaxosMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PaxosMsg *>(to)->MergeFrom(
      static_cast<const PaxosMsg &>(from));
}


void PaxosMsg::MergeFrom(const PaxosMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.PaxosMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  cientries_.MergeFrom(from.cientries_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_addr(from._internal_addr());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_extra(from._internal_extra());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_compressedentries()->::alisql::CompressedLogEntries::MergeFrom(from._internal_compressedentries());
    }
    if (cached_has_bits & 0x00000008u) {
      configid_ = from.configid_;
    }
    if (cached_has_bits & 0x00000010u) {
      clusterid_ = from.clusterid_;
    }
    if (cached_has_bits & 0x00000020u) {
      serverid_ = from.serverid_;
    }
    if (cached_has_bits & 0x00000040u) {
      term_ = from.term_;
    }
    if (cached_has_bits & 0x00000080u) {
      msgid_ = from.msgid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      leaderid_ = from.leaderid_;
    }
    if (cached_has_bits & 0x00000200u) {
      prevlogindex_ = from.prevlogindex_;
    }
    if (cached_has_bits & 0x00000400u) {
      prevlogterm_ = from.prevlogterm_;
    }
    if (cached_has_bits & 0x00000800u) {
      commitindex_ = from.commitindex_;
    }
    if (cached_has_bits & 0x00001000u) {
      msgtype_ = from.msgtype_;
    }
    if (cached_has_bits & 0x00002000u) {
      nocache_ = from.nocache_;
    }
    if (cached_has_bits & 0x00004000u) {
      issuccess_ = from.issuccess_;
    }
    if (cached_has_bits & 0x00008000u) {
      votegranted_ = from.votegranted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      ignorecheck_ = from.ignorecheck_;
    }
    if (cached_has_bits & 0x00020000u) {
      candidateid_ = from.candidateid_;
    }
    if (cached_has_bits & 0x00040000u) {
      lastlogindex_ = from.lastlogindex_;
    }
    if (cached_has_bits & 0x00080000u) {
      lastlogterm_ = from.lastlogterm_;
    }
    if (cached_has_bits & 0x00100000u) {
      force_ = from.force_;
    }
    if (cached_has_bits & 0x00200000u) {
      lctype_ = from.lctype_;
    }
    if (cached_has_bits & 0x00400000u) {
      minmatchindex_ = from.minmatchindex_;
    }
    if (cached_has_bits & 0x00800000u) {
      appliedindex_ = from.appliedindex_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x07000000u) {
    if (cached_has_bits & 0x01000000u) {
      newclusterid_ = from.newclusterid_;
    }
    if (cached_has_bits & 0x02000000u) {
      role_ = from.role_;
    }
    if (cached_has_bits & 0x04000000u) {
      msgerror_ = from.msgerror_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PaxosMsg::CopyFrom(const PaxosMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.PaxosMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PaxosMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entries_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(cientries_))
    return false;
  if (_internal_has_compressedentries()) {
    if (!compressedentries_->IsInitialized()) return false;
  }
  return true;
}

void PaxosMsg::InternalSwap(PaxosMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  entries_.InternalSwap(&other->entries_);
  cientries_.InternalSwap(&other->cientries_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &addr_, lhs_arena,
      &other->addr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &extra_, lhs_arena,
      &other->extra_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PaxosMsg, msgerror_)
      + sizeof(PaxosMsg::msgerror_)
      - PROTOBUF_FIELD_OFFSET(PaxosMsg, compressedentries_)>(
          reinterpret_cast<char*>(&compressedentries_),
          reinterpret_cast<char*>(&other->compressedentries_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PaxosMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[6]);
}

// ===================================================================

class TestMsg1::_Internal {
 public:
  using HasBits = decltype(std::declval<TestMsg1>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_c1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TestMsg1::TestMsg1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.TestMsg1)
}
TestMsg1::TestMsg1(const TestMsg1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&c1_) -
    reinterpret_cast<char*>(&id_)) + sizeof(c1_));
  // @@protoc_insertion_point(copy_constructor:alisql.TestMsg1)
}

inline void TestMsg1::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&c1_) -
    reinterpret_cast<char*>(&id_)) + sizeof(c1_));
}

TestMsg1::~TestMsg1() {
  // @@protoc_insertion_point(destructor:alisql.TestMsg1)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TestMsg1::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TestMsg1::ArenaDtor(void* object) {
  TestMsg1* _this = reinterpret_cast< TestMsg1* >(object);
  (void)_this;
}
void TestMsg1::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TestMsg1::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TestMsg1::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.TestMsg1)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&c1_) -
        reinterpret_cast<char*>(&id_)) + sizeof(c1_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TestMsg1::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 c1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_c1(&has_bits);
          c1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TestMsg1::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.TestMsg1)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // optional uint64 c1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_c1(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.TestMsg1)
  return target;
}

size_t TestMsg1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.TestMsg1)
  size_t total_size = 0;

  // required uint64 id = 1;
  if (_internal_has_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 c1 = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_c1());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TestMsg1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TestMsg1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TestMsg1::GetClassData() const { return &_class_data_; }

void TestMsg1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TestMsg1 *>(to)->MergeFrom(
      static_cast<const TestMsg1 &>(from));
}


void TestMsg1::MergeFrom(const TestMsg1& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.TestMsg1)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      c1_ = from.c1_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TestMsg1::CopyFrom(const TestMsg1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.TestMsg1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestMsg1::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TestMsg1::InternalSwap(TestMsg1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TestMsg1, c1_)
      + sizeof(TestMsg1::c1_)
      - PROTOBUF_FIELD_OFFSET(TestMsg1, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TestMsg1::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[7]);
}

// ===================================================================

class TestMsg2::_Internal {
 public:
  using HasBits = decltype(std::declval<TestMsg2>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_c1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TestMsg2::TestMsg2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  c2_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:alisql.TestMsg2)
}
TestMsg2::TestMsg2(const TestMsg2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      c2_(from.c2_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&c1_) -
    reinterpret_cast<char*>(&id_)) + sizeof(c1_));
  // @@protoc_insertion_point(copy_constructor:alisql.TestMsg2)
}

inline void TestMsg2::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&c1_) -
    reinterpret_cast<char*>(&id_)) + sizeof(c1_));
}

TestMsg2::~TestMsg2() {
  // @@protoc_insertion_point(destructor:alisql.TestMsg2)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TestMsg2::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TestMsg2::ArenaDtor(void* object) {
  TestMsg2* _this = reinterpret_cast< TestMsg2* >(object);
  (void)_this;
}
void TestMsg2::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TestMsg2::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TestMsg2::Clear() {
// @@protoc_insertion_point(message_clear_start:alisql.TestMsg2)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  c2_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&c1_) -
        reinterpret_cast<char*>(&id_)) + sizeof(c1_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TestMsg2::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 c1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_c1(&has_bits);
          c1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 c2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_c2(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_c2(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TestMsg2::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alisql.TestMsg2)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // optional uint64 c1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_c1(), target);
  }

  // repeated uint64 c2 = 3;
  for (int i = 0, n = this->_internal_c2_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_c2(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alisql.TestMsg2)
  return target;
}

size_t TestMsg2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alisql.TestMsg2)
  size_t total_size = 0;

  // required uint64 id = 1;
  if (_internal_has_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 c2 = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->c2_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_c2_size());
    total_size += data_size;
  }

  // optional uint64 c1 = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_c1());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TestMsg2::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TestMsg2::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TestMsg2::GetClassData() const { return &_class_data_; }

void TestMsg2::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TestMsg2 *>(to)->MergeFrom(
      static_cast<const TestMsg2 &>(from));
}


void TestMsg2::MergeFrom(const TestMsg2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:alisql.TestMsg2)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  c2_.MergeFrom(from.c2_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      c1_ = from.c1_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TestMsg2::CopyFrom(const TestMsg2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alisql.TestMsg2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestMsg2::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TestMsg2::InternalSwap(TestMsg2* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  c2_.InternalSwap(&other->c2_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TestMsg2, c1_)
      + sizeof(TestMsg2::c1_)
      - PROTOBUF_FIELD_OFFSET(TestMsg2, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TestMsg2::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_paxos_2eproto_getter, &descriptor_table_paxos_2eproto_once,
      file_level_metadata_paxos_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace alisql
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::alisql::LogEntry* Arena::CreateMaybeMessage< ::alisql::LogEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::LogEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::alisql::RDSFields* Arena::CreateMaybeMessage< ::alisql::RDSFields >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::RDSFields >(arena);
}
template<> PROTOBUF_NOINLINE ::alisql::PolarFields* Arena::CreateMaybeMessage< ::alisql::PolarFields >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::PolarFields >(arena);
}
template<> PROTOBUF_NOINLINE ::alisql::CompressedLogEntries* Arena::CreateMaybeMessage< ::alisql::CompressedLogEntries >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::CompressedLogEntries >(arena);
}
template<> PROTOBUF_NOINLINE ::alisql::ConfigureChangeValue* Arena::CreateMaybeMessage< ::alisql::ConfigureChangeValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::ConfigureChangeValue >(arena);
}
template<> PROTOBUF_NOINLINE ::alisql::ClusterInfoEntry* Arena::CreateMaybeMessage< ::alisql::ClusterInfoEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::ClusterInfoEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::alisql::PaxosMsg* Arena::CreateMaybeMessage< ::alisql::PaxosMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::PaxosMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::alisql::TestMsg1* Arena::CreateMaybeMessage< ::alisql::TestMsg1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::TestMsg1 >(arena);
}
template<> PROTOBUF_NOINLINE ::alisql::TestMsg2* Arena::CreateMaybeMessage< ::alisql::TestMsg2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alisql::TestMsg2 >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
